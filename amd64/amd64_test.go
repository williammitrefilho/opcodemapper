package amd64

import(
	"testing"
)

func TestNeedsModRM(t *testing.T){
	
	instructionBytes := []byte{
//Let's see if we can correctly disassemble 64-bit chrome.exe for x86-64, one instruction at a time
		
//		0x48, 0x89, 0x5C, 0x24, 0x20, 0x55,
//		0xE8, 0x0B, 0x00, 0x00, 0x00,
//		0x48, 0x89, 0x5C, 0x24, 0x20,
//		0x55,
//		0x48, 0x8B, 0xEC,
//		0x48, 0x83, 0xEC, 0x20,
//		0x48, 0x8B, 0x05, 0xB0, 0x9D, 0x10, 0x00,
//		0x48, 0xBB, 0x32, 0xA2, 0xDF, 0x2D, 0x99, 0x2B, 0x00, 0x00,
//		0x48, 0x3B, 0xC3
//		0x75, 0x74,
//		0x48, 0x8B, 0x5C, 0x24, 0x48,
		0x48, 0xF7, 0xD0,
	}
	if !opcodeMap[instructionBytes[1]].needsModRM(){
		
		t.Fatalf("said that byte 0x%x didn't need ModRM", instructionBytes[1])
	}
}

func TestSetModRM(t *testing.T){
	
	instructionBytes := []byte{
//Let's see if we can correctly disassemble 64-bit chrome.exe for x86-64, one instruction at a time
		
//		0x48, 0x89, 0x5C, 0x24, 0x20, 0x55,
//		0xE8, 0x0B, 0x00, 0x00, 0x00,
//		0x48, 0x89, 0x5C, 0x24, 0x20,
//		0x55,
//		0x48, 0x8B, 0xEC,
//		0x48, 0x83, 0xEC, 0x20,
//		0x48, 0x8B, 0x05, 0xB0, 0x9D, 0x10, 0x00,
//		0x48, 0xBB, 0x32, 0xA2, 0xDF, 0x2D, 0x99, 0x2B, 0x00, 0x00,
//		0x48, 0x3B, 0xC3
//		0x75, 0x74,
		0x48, 0x8B, 0x5C, 0x24, 0x48,
//		0x48, 0xF7, 0xD0,
	}
	
	var opcode opcode = *opcodeMap[instructionBytes[1]]
	if !opcode.needsModRM(){
		
		t.Fatalf("said that byte 0x%x didn't need ModRM", instructionBytes[1])
	}
	opcode.setModRM(instructionBytes[2])
	
	if opcode.Mnemonic != "MOV"{
		
		t.Fatalf("opcode Mnemonic: %v", opcode.Mnemonic)
	}
	if opcode.r_m != SIB{
		
		t.Fatalf("opcode r_m:%v", opcode.r_m)
	}
	opcode.setSIBByte(instructionBytes[3])
	if opcode.scale != 1{
		
		t.Fatalf("opcode SIB.scale is %v", opcode.scale)
	}
	if opcode.r_m != RSP{
		
		t.Fatalf("opcode.r_m is %v", opcode.r_m)
	}
	if opcode.displacementBytes != 1{
		
		t.Fatalf("opcode displacementBytes is %v", opcode.displacementBytes)
	}
}

func TestFeedByte(t *testing.T){
	instructionBytes := []byte{
		
//		0x48, 0x89, 0x5C, 0x24, 0x20, 0x55,
//		0xE8, 0x0B, 0x00, 0x00, 0x00,
//		0x48, 0x89, 0x5C, 0x24, 0x20,
//		0x55,
//		0x48, 0x8B, 0xEC,
//		0x48, 0x83, 0xEC, 0x20,
//		0x48, 0x8B, 0x05, 0xB0, 0x9D, 0x10, 0x00,
//		0x48, 0xBB, 0x32, 0xA2, 0xDF, 0x2D, 0x99, 0x2B, 0x00, 0x00,
//		0x48, 0x3B, 0xC3
//		0x75, 0x74,
		0x48, 0x8B, 0x5C, 0x24, 0x48,
//		0x48, 0xF7, 0xD0,
	}
	
	instr := new(Instruction)
	r := instr.feedByte(instructionBytes[0])
	if r != 1{
		
		t.Fatalf("r is %v", r)
	}
	r = instr.feedByte(instructionBytes[1])
	if r != 1{
		
		t.Fatalf("r is %v", r)
	}
	if instr.Opcode == nil{
		
		t.Fatalf("opcode is nil")
	}
	r = instr.feedByte(instructionBytes[2])
	if r != 1{
		
		t.Fatalf("r is %v", r)
	}
	if instr.Opcode.needsModRM(){
		
		t.Fatalf("instr still asking for ModRM")
	}
	if instr.Opcode.r_m != SIB{
		
		t.Fatalf("instr's r_m field is %v", instr.Opcode.r_m)
	}
	r = instr.feedByte(instructionBytes[3])
	if r != 0{
		
		t.Fatalf("r is %v", r)
	}
	if !instr.finished{
		
		t.Fatalf("instr is not finished")
	}
	if instr.Opcode.r_m == SIB{
		
		t.Fatalf("instr's r_m field is still SIB")
	}
	if instr.Opcode.displacementBytes != 1{
		
		t.Fatalf("instr's displacementBytes is %v", instr.Opcode.displacementBytes)
	}
	if instr.Opcode.immediateBytes != 0{
		
		t.Fatalf("instr's immediateBytes is %v", instr.Opcode.immediateBytes)
	}
}

func TestInstructionFromBytes(t *testing.T){
	
	instructionBytes := []byte{
		
//		0xE8, 0x0B, 0x00, 0x00, 0x00,
//		0x48, 0x89, 0x5C, 0x24, 0x20,
//		0x55,
//		0x48, 0x8B, 0xEC,
//		0x48, 0x83, 0xEC, 0x20,
//		0x48, 0x8B, 0x05, 0xB0, 0x9D, 0x10, 0x00,
//		0x48, 0xBB, 0x32, 0xA2, 0xDF, 0x2D, 0x99, 0x2B, 0x00, 0x00,
//		0x48, 0x3B, 0xC3
//		0x75, 0x74,
//		0x48, 0x8B, 0x5C, 0x24, 0x48,
		0x48, 0xF7, 0xD0,
	}
	instr := InstructionFromBytes(instructionBytes)
	if instr == nil{
		
		t.Fatalf("instruction is nil")
	}
	if instr.Opcode.Mnemonic != "NOT"{
		
		t.Fatalf("Mnemonic is %v", instr.Opcode.Mnemonic)
	}
	if instr.Opcode.immediateBytes != 0{
		
		t.Fatalf("immediateBytes is %v", instr.Opcode.immediateBytes)
	}
	total_len := instr.nBytes + instr.Opcode.immediateBytes + instr.Opcode.displacementBytes
	if(total_len != 3){
		
		t.Fatalf("total len is %v (%v, %v, %v)", total_len, instr.nBytes, instr.Opcode.immediateBytes, instr.Opcode.displacementBytes)
	}
	if instr.Immediate != 0{
		
		t.Fatalf("immediate is %x", instr.Immediate)
	}
}

func TestProcessorRun(t *testing.T){
	
	instructionBytes := []byte{
//Let's see if we can correctly disassemble this snippet of code from chrome.exe
		
		0xE8, 0x0B, 0x00, 0x00, 0x00,
		0x48, 0x89, 0x5C, 0x24, 0x20,
		0x55,
		0x48, 0x8B, 0xEC,
		0x48, 0x83, 0xEC, 0x20,
		0x48, 0x8B, 0x05, 0xB0, 0x9D, 0x10, 0x00,
		0x48, 0xBB, 0x32, 0xA2, 0xDF, 0x2D, 0x99, 0x2B, 0x00, 0x00,
		0x48, 0x3B, 0xC3,
		0x75, 0x74,
		0x48, 0x8B, 0x5C, 0x24, 0x48,
		0x48, 0xF7, 0xD0,
	}
	p := New()
	p.LoadCode(instructionBytes)
	instrs, err := p.Run()
	if(err != nil){
		
		t.Fatalf(err.Error())
	}
	if(len(instrs) != 11){
		
		t.Fatalf("there are %v instructions in the processor, and the IP is at %v", len(instrs), p.ip)
	}
}